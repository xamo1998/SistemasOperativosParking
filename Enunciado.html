<html><head>
    <title>Sistemas Operativos II - Primera práctica evaluable</title>
</head>
<body>
    <h1><center>PRÁCTICAS DE SISTEMAS OPERATIVOS II</center></h1>
    <h2><center>PRIMERA PRÁCTICA EVALUABLE</center></h2>
    <h2><center>Aparcando</center></h2>
<hr>
    <ol>
        <li><h3>Enunciado.</h3>
            En esta práctica vamos a simular, mediante procesos de UNIX,
            la gestión de memoria de un sistema operativo que use
            particiones de tamaño dinámico. Para ello, se establece el
            símil con el problema de elegir el mejor aparcamiento para un coche
            de todos los posibles en una acera. Según se va ejecutando el programa, 
            se ha de ver una imagen parecida a la siguiente:
            <br><br>
            <center><img alt="Captura de pantalla" src="parking.png"></center>
            <br><br>
            El programa constará de un único fichero fuente,
            <code>parking.c</code>, cuya adecuada compilación producirá
            el ejecutable <code>parking</code>. Respetad las 
            mayúsculas/minúsculas de los nombres.
            <br><br>
            Para simplificar la realización de la práctica, se os proporciona
            una biblioteca estática de funciones (<code>libparking.a</code>)
            que debéis enlazar con vuestro módulo objeto para generar el
            ejecutable. Gracias a ella, algunas de las funciones necesarias
            para realizar la práctica no las tendréis
            que programar sino que bastará nada más con incluir
            la biblioteca cuando compiléis el programa. La línea de
            compilación del programa podría ser:
<pre>gcc parking.c libparking.a -o parking -lm</pre>
            Disponéis, además, de un fichero de cabeceras,
            <code>parking.h</code>, donde se encuentran definidas, entre
            otras cosas, las macros que usa la biblioteca.
            <br><br>
            En la imagen puede observarse de color marrón lo que simulan ser cuatro
            aceras. El algoritmo que se usa para aparcar los coches en cada
            una corresponde, de arriba a abajo, al <i>primer ajuste</i>,
            <i>siguiente ajuste</i>, <i>mejor ajuste</i> y <i>peor ajuste</i>,
            tal y como se vio anteriormente en la teoría de Sistemas Operativos. Cada acera
            consta de ochenta caracteres (x=0 a x=79), numerados de izquierda a derecha.
            La coordenada <i>y</i> puede tomar valores entre 0 y 2, siendo 0 la calzada justo
            al lado de la acera, 1, la posición sobre las rayas de aparcamiento y 2,
            el carril de circulación.
            Los coches tienen longitud entera, medida en caracteres.
            <br><br>
            Quizá de los cuatro algoritmos el que mayor dificultad presente sea 
            el del <i>siguiente ajuste</i>. Cuando un coche llega a aparcar, de 
            todos los huecos en los que cabe el coche, se elige el primero que 
            aparece a partir de la posición en la que aparcó el último coche.
            Si se llega al final de la acera, se vuelve a empezar por el 
            principio.
            El algoritmo no presenta mayor problema salvo cuando el último coche
            que aparcó ya se ha ido y también está libre la posición
            actual. En ese caso, se empieza a buscar por el comienzo del hueco donde se halla
            la posición actual.
            <br><br>
            En el caso de los algoritmos del <i>mejor ajuste</i> y del
            <i>peor ajuste</i>, si hay empate entre dos o más huecos, se elegirá
            entre ellos siguiendo el criterio del <i>primer ajuste</i>.
            <br><br>
            Una vez elegido un hueco con espacio suficiente para aparcar el coche,
            se aparcará ajustando el coche a la izquierda del hueco en cualquiera
            de los algoritmos.
            <br><br>
            Si cuando llega un coche, no existe un hueco de tamaño suficiente para
            que aparque, el coche se pondrá en una cola a la espera de que otro
            coche salga del aparcamiento. Esta cola seguirá una disciplina FIFO.
            <br><br>
            Los coches tienen un número que los identifica.  Los coches deben aparcar
            en orden consecutivo.  Vuestro programa debe garantizar que el orden se respeta,
            pues de no hacer nada, algunos coches podrían adelantarse debido al
            reparto de CPU.  También tienen los coches un color y una velocidad
            propias.
            <br><br>
            Para que en la forma de desarrollarse de cada algoritmo no influya la suerte,
            en cada ejecución concreta llegarán los mismos coches, con idéntico
            tiempo de servicio e intervalo de llegada entre ellos a cada una de
            las cuatro aceras. Para el tiempo de servicio y el intervalo de llegada
            entre coches, se usará una distribución exponencial. Para la longitud
            de los coches, la distribución será uniforme, con una longitud comprendida
            7 y 17 caracteres.
            <br><br>
            Para facilitar la tarea, tenéis a vuestra disposición
            una biblioteca de funciones de enlazado estático
            <code>libparking.a</code> y un fichero de cabeceras,
            <code>parking.h</code>.
            Gracias a la biblioteca, muchas de las funciones no las tendréis
            que programar sino que invocarlas a la biblioteca.
            También estará a cargo de la biblioteca muchos de los detalles
            de la práctica: llegadas y salidas de coches, gestión
            de la cola de espera, etc.  Una descripción
            detallada de las funciones de la biblioteca aparece más abajo 
            en esta misma página.
            <br><br>
            Además del proceso padre, necesitaréis crear algunos procesos
            hijos más.  En concreto, existirán unos procesos <i>chóferes</i>
            que se dedicarán a aparcar y desaparcar los coches.  Estos procesos siguen
            una estrategia denominada <i>cuadrilla de trabajadores</i> (<i>pool of workers</i>).
            Consiste en que se quedan en espera a que les llegue una petición de
            aparcar o desaparcar un coche.  Una vez realizada la tarea, vuelven a quedarse
            a la espera de recibir otra solicitud.  También existe un hijo adicional
            del proceso padre que se encargará de contar el tiempo que dura la simulación
            e invocar a la función <code>PARKING_fin</code>.  Es posible que
            necesitéis, adicionalmente, un proceso gestor para tramitar los mensajes
            recibidos de la biblioteca a través del buzón.
            <br><br>
            El programa, desde vuestro punto de vista, se simplifica
            bastante. El proceso padre ha de:
            <ol>
              <li> comprobar los argumentos pasados por la línea de órdenes</li>
              <li> registrar las manejadoras</li>
              <li> crear los recursos IPCs necesarios: array de semáforos, buzón
                   y zona de memoria compartida</li>
              <li> llamar a la función <code>PARKING_inicio</code></li>
              <li> crear los procesos chóferes y el proceso que avisa</li>
              <li> invocar la función <code>PARKING_simulaciOn</code></li>
            </ol>
            <br><br>
            Para que el programa funcione correctamente, es necesario crear un array de
            semáforos, un buzón de paso de mensajes y una zona de memoria
            compartida privados.  Parte de estos recursos los necesita la biblioteca
            y el resto que reservéis los podéis usar para sincronizar
            y comunicar los procesos entre sí.  En concreto, hay dos funciones
            auxiliares que os indican cuántos semáforos necesita la
            biblioteca (<code>PARKING_getNSemAforos</code>) y cuántos bytes
            de memoria compartida requiere la biblioteca
            (<code>PARKING_getTamaNoMemoriaCompartida</code>).  Tanto los semáforos
            como la zona de memoria usados por la biblioteca estarán situados 
            al inicio del recurso reservado.
            <br><br>
            Por su parte, la vida de los procesos chóferes transcurre
            plácida y tranquila, como ya se ha explicado.  Duermen hasta
            recibir una petición de aparcar o desaparcar e invocan las
            funciones <code>PARKING_aparcar</code> y <code>PARKING_desaparcar</code>,
            respectivamente.  Solamente deben tener cuidado de no llamar
            a la función de aparcamiento hasta que los coches con un
            número inferior al suyo ya la hayan invocado y recibido
            confirmación de la biblioteca.
            <br><br>
            Cuando hay que aparcar o desaparcar un coche, la biblioteca manda
            un mensaje al buzón de tipo <code>PARKING_MSG</code> y
            subtipos <code>PARKING_MSGSUB_APARCAR</code> y
            <code>PARKING_MSGSUB_DESAPARCAR</code>, respectivamente.
            El formato de estos mensajes se puede deducir de la definición
            de <code>struct PARKING_mensajeBiblioteca</code> que se encuentra
            en el fichero <code>parking.h</code>.
            <br><br>
            De haber varias peticiones sin atender, dependiendo de cómo
            se haya invocado la práctica, se debe seguir una política:
            <ul>
              <li>FIFO (no se especifica nada en la línea de órdenes)</li>
              <li>de prioridad para los aparcamientos (especificamos <code>PA</code>)</li>
              <li>de prioridad para desaparcar (se especifica <code>PD</code>)</li>
            </ul>
            Para lograrlo, se puede usar un proceso gestor que tramite los mensajes,
            los reescriba, renumere y reenvíe o, cualquier otro método
            que logre los resultados que se pretenden.
            <br><br>
            Cada coche que participa en la simulación tiene un manejador
            opaco de tipo <code>HCoche</code> para poder trabajar con él.
            Existen funciones que permiten conocer las características de
            los coches mediante su manejador.  Un listado exhaustivo se ofrece
            más abajo.
            <br><br>
            Se deben programar cuatro funciones, una por algoritmo, que serán
            llamadas por la biblioteca cada vez que un coche llegue. Dichas
            <i>funciones de rellamada</i> son registradas en la función
            <code>PARKING_inicio</code> de la biblioteca.
            <br><br>
            El prototipo de las funciones de rellamada se describe aquí:
            <ul>
                <li><code><strong>int funciOn_llegada(HCoche hc);
                    </strong></code><br>
                    La biblioteca llamará a una de estas funciones cuando llegue un nuevo
                    coche. La respuesta que debe devolver vuestro código
                    indicará qué se debe hacer con ese coche. -1 indica
                    que no hay sitio para él y debe encolarse. Un valor entre
                    0 y 79 significa la posición a partir de la cual se debe
                    aparcar el coche.  Además, si devolvemos -2, indicaremos
                    a la biblioteca que no queremos procesar más coches de
                    ese algoritmo, lo que puede ser útil para anular uno o
                    varios algoritmos para depurar los demás.</li>
            </ul>
            <br><br>
            La funciones <code>PARKING_aparcar</code> y <code>PARKING_desaparcar</code> son
            especiales puesto que gestionan el movimiento de los coches automáticamente
            mediante funciones de rellamada a vuestro código.  Estos son sus prototipos
            con la correspondiente explicación:
            <ul>
                <li><code><strong>int PARKING_aparcar(HCoche,void *datos,
                                             TIPO_FUNCION_APARCAR_COMMIT,
                                             TIPO_FUNCION_PERMISO_AVANCE,
                                             TIPO_FUNCION_PERMISO_AVANCE_COMMIT;
                    </strong></code><br>
                    La biblioteca puede llamar a la función de llegada en cualquier
                    orden y es responsabilidad del programador que los coches se
                    aparquen en orden numérico.  Para ello, se debe invocar
                    la función <code>PARKING_aparcar</code> del coche que
                    toque y no invocar a la función del coche
                    siguiente hasta haber recibido la rellamada de <i>aparcar
                    commit</i>.  Esta rellamada indica que la biblioteca ha tomado
                    nota de la anterior llamada y ya se puede invocar al siguiente.
                    <br><br>
                    El avance del coche también se regula mediante dos funciones
                    de rellamada que se especifican en esta función.  Cada vez
                    que un coche quiere avanzar, la biblioteca invoca a nuestra función
                    de <i>permiso avance</i>.  Debemos bloquearnos, sin consumir CPU,
                    hasta que el avance sea seguro.  En esos momentos, la biblioteca produce
                    el avance en el coche y nos avisa a través de la
                    función <i>permiso avance commit</i>.</li>
                <li><code><strong>int PARKING_desaparcar(HCoche,void *datos,
                                             TIPO_FUNCION_PERMISO_AVANCE,
                                             TIPO_FUNCION_PERMISO_AVANCE_COMMIT);
                    </strong></code><br>
                    La descripción de esta función es equivalente
                    a la de la función anterior, con la salvedad de que,
                    al no importar el orden en que se desaparca, no es necesaria
                    una función de confirmación (<i>commit</i>) en
                    este caso.</li>
            </ul>
            <br><br>
            <h4>Características adicionales que programar</h4>
            <ul>
                <li>El programa no debe consumir CPU apreciablemente
                    en los modos de retardo mayor o igual que 1.
                    para comprobar el consumo de CPU, podéis 
                    usar la orden <code>top</code>.</li>
                <li><strong>IMPORTANTE</strong>: Aunque no se indique
                    explícitamente en el enunciado, parece obvio que
                    se necesitarán objetos de sincronización en diferentes
                    partes del programa.</li>
                <li>Se permite hacer semiespera ocupada cuando un chófer
                    espera a que le toque a su coche aparcar, pero de hacerse así,
                    la nota puede verse rebajada.</li>
                <li>El tiempo de ejecución de la práctica será
                    de 30 segundos.  El proceso encargado de llevar la cuenta no puede
                    usar la llamada <code>sleep</code>, sino hacerlo mediante la
                    señal <code>SIGALRM</code>.</li>
            </ul> 
            <br><br>

            <code>Parking</code> acepta un mínimo de dos y un máximo de cuatro
            argumentos por
            la línea de órdenes. Si no se introducen argumentos, se imprimirá
            un mensaje con la forma de uso del programa por el canal de
            error estándar. En el caso de teclear dos argumentos, el primer argumento
            será un número entero mayor o igual que cero 
            relacionado con la rapidez con que se producen los acontecimientos
            en el programa. Cero indica la máxima rapidez y números
            mayores suponen una rapidez progresivamente menor.  El segundo argumento
            es el número de chóferes que se usarán en esta
            ejecución.  Finalmente, si son más de dos
            los argumentos introducidos, los dos primeros son idénticos
            al caso anterior y el resto podrá ser una combinación
            cualquiera de:
            <ul><li><code>D</code>, indicando que se desea que el programa produzca 
                         información de depuración por
                         el canal de errores estándar</li>
                 <li><code>PA</code>, para que se dé prioridad a los que aparcan</li>
                 <li><code>PD</code>, para que se dé prioridad a los que desaparcan</li>
            </ul>
            La única combinación que no se permitirá será
            <code>PA</code> y <code>PD</code> a la vez, por contradictoria.  Por ejemplo,
            para una velocidad 10, cinco chóferes, con información de
            depuración y prioridad para los que desaparcan, se podría
            invocar así: <code>parking 10 5 PD D</code>
            <br><br>
            El programa debe estar preparado para que, si el usuario pulsa
            las teclas CTRL-C desde el terminal, la ejecución del programa
            termine en ese momento y adecuadamente. Ni en una terminación
            como esta, ni en una normal, deben quedar procesos en ejecución
            ni mecanismos IPC sin haber sido borrados del sistema. Este es
            un aspecto muy importante y se penalizará bastante si la práctica
            no lo cumple.
            <br><br>
            Es probable que necesitéis semáforos para sincronizar
            adecuadamente la práctica. Se declarará una array de semáforos
            de tamaño adecuado a vuestros requerimientos,
            los primeros de los cuales se reservarán para el funcionamiento
            interno de la biblioteca, como se indicó más arriba.
            El resto, podéis usarlos libremente.  Del mismo modo, la memoria
            compartida reservada se divide en dos partes, la primera de las cuales
            es para uso interno de la biblioteca.
            <br><br>
            Las funciones proporcionadas por la biblioteca 
            <code>libparking.a</code> son las que a continuación aparecen. 
            De no indicarse nada, las funciones devuelven -1 en caso de 
            error:
            <ul>
                <li><code><strong>int PARKING_inicio(int ret, 
                    TIPO_FUNCION_LLEGADA f_llegadas[],
                    int semAforos, int buzOn, int zona, int debug)
                    </strong></code><br>
                    El proceso padre debe llamar a esta función cuando desee
                    que la simulación comience. La función devuelve -1
                    si se ha producido un error. Los argumentos son:
                    <ol>
                        <li><code>ret</code>: lentitud de ejecución. Es el valor
                            que se ha pasado como primer argumento al programa.</li>
                        <li><code>f_llegadas</code>: es un array de cuatro
                            elementos. Contiene los punteros a las funciones
                            de vuestro programa que queréis que la biblioteca invoque
                            cada vez que llega un coche nuevo para cada
                            algoritmo. El prototipo de
                            las funciones se ha especificado más arriba.</li>
                        <li><code>semAforos</code>: identificador del
                            array de semáforos devuelto por
                            <code>semget</code>.</li>
                        <li><code>buzOn</code>: idem para el buzón
                            de paso de mensajes.</li>
                        <li><code>zona</code>: idem para la zona de
                            memoria compartida (no es el puntero, sino lo
                            que devuelve <code>shmget</code>).</li>
                        <li><code>debug</code>: flag que indica si se desea
                            que la biblioteca produzca información de
                            depuración por el canal de errores estándar.</li>
                    </ol></li>
                <li><code><strong>void PARKING_aparcar(HCoche hc,void *datos,
                                             void (*fCommit)(HCoche),
                                             void (*fPermisoAvance)(HCoche),
                                             void (*fPermisoAvanceCommit)(HCoche))
                    </strong></code><br>
                    Se invoca esta función cuando queremos que aparezca por
                    la pantalla la animación de un coche aparcando y siempre
                    respetando el orden numérico de los coches:
                    <ol>
                        <li><code>hc</code>: manejador del coche que queremos aparcar.</li>
                        <li><code>datos</code>: puntero de datos que podemos asociar al
                            coche para recuperarlos en cualquier otro momento.</li>
                        <li><code>fCommit</code>: manejadora que será invocada cuando
                            la biblioteca haya anotado la salida del coche.</li>
                        <li><code>fPermisoAvance</code>: manejadora que es llamada por la
                            biblioteca antes de efectuar un movimiento del coche para aparcar.
                            A través del manejador del coche que se nos pasa, podremos
                            obtener su información.  En particular, su posición
                            (funciones <code>PARING_getX()</code> y <code>PARKING_getY()</code>),
                            la posición a la que desea ir
                            (funciones <code>PARING_getX2()</code> y <code>PARKING_getY2()</code>),
                            el puntero a los datos que hemos asociado al coche
                            (función <code>PARKING_getDatos()</code>), etc.
                            La función se debe bloquear sin consumo de CPU hasta que
                            sea seguro para el coche el avance.</li>
                        <li><code>fPermisoAvanceCommit</code>: esta manejadora será
                            invocada por la biblioteca cuando ha hecho efectivo el avance del coche.
                            En este caso, las coordenadas (<i>x</i>,<i>y</i>) se corresponden
                            con la posición ya avanzada del coche y (<i>x2</i>,<i>y2</i>)
                            son las coordenadas de la posición antes de avanzar.</li>
                    </ol></li>
                <li><code><strong>void PARKING_desaparcar(HCoche hc,void *datos,
                                             void (*fPermisoAvance)(HCoche),
                                             void (*fPermisoAvanceCommit)(HCoche))
                    </strong></code><br>
                    Idéntica a la función anterior, sólo que para que se muestre
                    la salida de un coche.  En este caso no aparece la función <i>commit</i>
                    pues se hace innecesaria, al no ser un requisito que desaparquen en un
                    determinado orden.</li>
                <li><code><strong>int PARKING_getNUmero(HCoche hc)<br>
                                  int PARKING_getLongitud(HCoche hc)<br>
                                  int PARKING_getPosiciOnEnAcera(HCoche hc)<br>
                                  int PARKING_getColor(HCoche hc)<br>
                                  int PARKING_getX(HCoche hc)<br>
                                  int PARKING_getY(HCoche hc)<br>
                                  int PARKING_getX2(HCoche hc)<br>
                                  int PARKING_getY2(HCoche hc)<br>
                                  int PARKING_getAlgoritmo(HCoche hc)<br>
                                  unsigned long PARKING_getTServ(HCoche hc)<br>
                                  void *PARKING_getDatos(HCoche hc)<br>
                    </strong></code><br>
                    Todas estas funciones dan información relativa al coche cuyo
                    manejador se pasa como parámetro.  Dicha información es,
                    respectivamente:
                    <ol>
                      <li>número del coche</li>
                      <li>longitud del coche</li>
                      <li>posición <i>x</i> en la acera donde ese coche va a
                          aparcar o -1 si todavía no está decidido</li>
                      <li>color del coche</li>
                      <li>coordenada <i>x</i> de la posición del coche donde se encuentra</li>
                      <li>lo mismo para la coordenada <i>y</i></li>
                      <li>coordenada <i>x</i> de la posición a la que quiere avanzar el
                          coche (función de permiso de avance) o de la que viene
                          (función de confirmación de permiso de avance)</li>
                      <li>idem coordenada <i>y</i></li>
                      <li>algoritmo al que pertenece el coche (<code>PRIMER_AJUSTE</code>,
                          <code>SIGUIENTE_AJUSTE</code>, <code>MEJOR_AJUSTE</code> y
                          <code>PEOR_AJUSTE</code>, según vienen definidas en el
                          fichero de cabeceras)</li>
                      <li>tiempo de servicio en unidades de tiempo de la simulación</li>
                      <li>puntero de datos que se le ha asignado al coche en la función de
                          aparcar</li>
                    </ol></li>
                <li><code><strong>int PARKING_isAceraOcupada(int algoritmo,int pos)
                    </strong></code><br>
                    Devuelve verdadero si la posición (0-79) de la acera (0-3)
                    indicadas en sus argumentos está ocupada por un coche, desde
                    el punto de vista de la biblioteca.  Solamente debe usarse como
                    depuración.  El estado de las aceras en cada momento lo
                    debe gestionar vuestra aplicación con sus propias variables.</li>
                <li><code><strong>int PARKING_getTamaNoMemoriaCompartida()<br>
                                  int PARKING_getNSemAforos()</strong></code><br>
                    Estas funciones devuelven los requerimientos de la biblioteca
                    respecto a la memoria compartida (bytes) o número de
                    semáforos</li>
                <li><code><strong>int PARKING_fin(int tipo)
                    </strong></code><br>
                    Se debe llamar a esta función cuando se desee terminar la
                    simulación. Si se trata de una terminación normal,
                    se le pasará un 1.  Si es por un error, se le pasará
                    un cero.</li>
                <li><code><strong>void pon_error(char *mensaje)
                    </strong></code><br>
                    Pone un mensaje de error en la
                    parte inferior de la pantalla y espera a que el
                    usuario pulse "Intro". La podéis usar para depurar.</li>
            </ul>
            <br><br>
            Estad atentos pues pueden ir saliendo versiones nuevas de la
            biblioteca para corregir errores o dotarla de nuevas funciones.
            <br><br>
            Respecto a la sincronización interna de la biblioteca, se
            usa un semáforo reservado para conseguir atomicidad en la 
            actualización de la pantalla (<i>semPantalla</i>, iniciado a 1),
            otro semáforo para evitar consumo de CPU innecesario en la
            simulación (<i>semSim</i>, iniciado a 0) y
            cuatro semáforos adicionales para secciones críticas
            para cada uno de los cuatro algoritmos (<i>semAlgoritmo[]</i>,
            iniciados a 1).
            Para que las sincronizaciones que de seguro deberéis hacer
            en vuestro código estén en sintonía con las de la biblioteca,
            os ofrecemos ahora un seudocódigo de algunas de
            las funciones que realiza la biblioteca y están reguladas por los
            semáforos.
            <pre>    * PARKING_inicio:
         - da valores iniciales a los recursos IPC de la biblioteca
         - dar valor inicial a los parámetros de la simulación
         - iniciar el generador de números aleatorios
         - limpiar la pantalla, poner mensaje inicial y dibujar

    * PARKING_fin:
         - si es normal, marcar acabando
         - si es por error, hacer que el cursor sea visible

    * PARKING_simulaciOn:
         - comienzo del bucle de simulación
         -   cálculo del próximo suceso (llegada o salida)
         -   dormir hasta que llegue el suceso o se avise mediante semSim
         -   avanzar el reloj de la simulación
         -   para todos los algoritmos a
         -     W(semAlgoritmo[a])
         -       pasar los recién aparcados a la lista de aparcados
         -       destruir los coches recién desaparcados
         -     S(semAlgoritmo[a])
         -   si toca acabar, salir del bucle
         -   para todos los algoritmos a
         -     mandar mensaje por cada coche cuyo tiempo de espera ha expirado (desaparcar)
         -   si estamos acabando, continuar el bucle
         -   mientras el tiempo de llegada del próximo coche sea menor que
               el reloj actual, crear un nuevo coche y encolarlo en la lista de espera
         -   para todos los coches que estén en la lista de espera
         -     W(semAlgoritmo[a])
         -       llamar a la función de llegada del algoritmo para ese coche
         -       si la posición devuelta es -2
                   poner t_siguiente llegada muy alto; S(semAlgoritmo[a]); break
         -       si la posición calculada es incorrecta
                   poner el error; S(semAlgoritmo[a]); break
         -       si la posición calculada es -1
                   S(semAlgoritmo[a]); break
         -       dibujar la reserva
         -       mandar mensaje de aparcar
         -     S(semAlgoritmo[a])
         - fin del bucle de la simulación

    * PARKING_aparcar:
         - si no le toca a este coche, poner el error
         - W(semAlgoritmo[a]); incrementar el número que toca; S(semAlgoritmo[a]);
         - almacenar el puntero de los datos de usuario pasado en el coche
         - desde la pos=79 hasta la posición en que el coche tiene que aparcarse
         -   pausa de avance
         -   llamar a permiso de avance
         -   dibujar el coche
         -   llamar a permiso de avance commit
         -   si pos=79, llamar a aparcar commit
         - hacer lo mismo para los dos avances verticales para acabar de aparcar
         - W(semAlgoritmo[a])
         -   encolar el coche en los recién aparcados
         -   avisar con semSim
         - S(semAlgoritmo[a])

    * PARKING_desaparcar:
         - permiso avance, dibujo y llamar a avance commit para el primer avance vertical
         - permiso avance para el segundo avance vertical
         - W(semAlgoritmo[a])
         -   dibujar el coche
         -   liberar la reserva de la acera
         -   llamar a permiso avance commit
         - S(semAlgoritmo[a])
         - hasta que el coche desaparece: pausa, permiso avance, dibujo, llamar a avance commit
         - W(semAlgoritmo[a])
         -   meter el coche en la lista de recién desaparcados
         -   avisar con semSim
         - S(semAlgoritmo[a])
    </pre>
            En esta práctica no se podrán usar ficheros para nada,
            salvo que se indique expresamente. Las comunicaciones de PIDs 
            o similares entre procesos, si hicieran falta, se harán mediante
            <i>mecanismos IPC</i>.
            <br><br>
            Siempre que en el enunciado o LPEs se diga que se puede usar
            <code>sleep()</code>, se refiere a la <i>llamada al sistema</i>,
            no a la orden de la línea de órdenes.
            <br><br>
            Los mecanismos IPC (semáforos, memoria compartida y paso
            de mensajes) son recursos muy limitados. Es por ello, que
            vuestra práctica sólo podrá usar un conjunto de semáforos,
            un buzón de paso de mensajes y una zona de memoria compartida
            como máximo. Además, si se produce cualquier error o se
            finaliza normalmente, los recursos creados han de ser eliminados.
            Una manera fácil de lograrlo es registrar la señal SIGINT
            para que lo haga y mandársela uno mismo si se produce un error.
            <br><br>
            <h4>Biblioteca de funciones <code>libparking.a</code></h4>
            Con esta práctica se trata de que aprendáis a sincronizar y
            comunicar procesos en UNIX entre sí. Su objetivo no es la programación,
            aunque es inevitable que tengáis que programar.
            Es por ello que se os suministra una biblioteca estática de
            funciones ya programadas para tratar de que no debáis
            preocuparos por la presentación por pantalla, la gestión de
            estructuras de datos (colas, pilas, ...) , etc. También servirá
            para que se detecten de un modo automático errores que se
            produzcan en vuestro código. Para que vuestro programa funcione,
            necesitáis la propia biblioteca <code>libparking.a</code>
            y el fichero de cabecera <code>parking.h</code>. La biblioteca
            funciona con los códigos de VT100/xterm, por lo que debéis adecuar
            vuestros simuladores a este terminal.
            <h5>Ficheros necesarios:</h5>
            <ul>
                <li><code>libparking.a</code>: 
                    <a href="UNIX/SOLARIS/libparking.a">para Solaris</a> (ver 2.2), 
                    <a href="UNIX/LINUX/libparking.a">para el LINUX de 
                        clase</a> (ver 2.2), </li>
                <li><code>parking.h</code>:
                    <a href="UNIX/parking.h">Para todos</a> (ver 2.0).</li>
            </ul>
            <br></li>
        <li><h3>Pasos recomendados para la realización de la práctica</h3>
            Aunque ya deberíais ser capaces de abordar la práctica sin
            ayuda, aquí van unas guías generales:
            <ol>
                <li>Hacer el código necesario para gestionar los argumentos
                    que se le pasan al programa</li>
                <li>Crear los semáforos, la memoria comparida y el buzón, y 
                    comprobad que se crean bien, con <code>ipcs</code>.
                    Es preferible, para que no haya interferencias, que
                    los defináis privados.</li>
                <li>Registrar SIGINT para que cuando se pulse ^C se eliminen 
                    los recursos IPC. Lograr que si el programa acaba 
                    normalmente o se produce cualquier error, también se 
                    eliminen los recursos
                    (mandad una señal SIGINT en esos casos al proceso padre).</li>
                <li>Llamar a la función <code>PARKING_inicio</code> en
                    <code>main</code>. Debe aparecer la pantalla de bienvenida
                    y, pasados dos segundos, dibujarse la pantalla.  Para el
                    array de funciones de llegada, usad funciones que nada
                    más tengan un <code>pause()</code> dentro, de
                    momento.  Todos los procesos que se creen a
                    continuación en sucesivos puntos deben crearse
                    después de haber llamado a
                    <code>PARKING_inicio</code>.</li>
                <li>Dejad a padre en <code>pause()</code> y cread el hijo que se
                    encarga de contar el tiempo y avisa al padre llamando a
                    <code>PARKING_fin()</code>.  Recordad que tenéis
                    que usar <code>SIGALRM</code> para eso y no <code>sleep</code></li>
                <li>A continuación, haced que el padre llame a
                    <code>PARKING_simulaciOn()</code></li>
                <li>Los siguientes pasos conllevan resolver la práctica solo
                    para un algoritmo y con un chófer, para ir, poco a poco,
                    aumentando la dificultad.  Para ello, solo programad la función
                    de llegada del primer algoritmo.  El resto de funciones de llegada,
                    que devuelvan -2 para indicar a la biblioteca que no queréis,
                    de momento, tratar con ellas.  Y el chófer, que solo lea
                    el mensaje y lo imprima en la pantalla.</li>
                <li>Que el chófer llame ahora a <code>PARKING_aparcar</code>.
                    Podéis hacer que las funciones de commits y permisos, de
                    momento, solo pongan un mensaje de depuración.</li>
                <li>Que el chófer distinga entre los dos tipos de mensajes
                    y llame a <code>PARKING_aparcar</code> o <code>PARKING_desaparcar</code>,
                    según corresponda.  Ya deberíais ser capaces de
                    ver a los coches aparcar y salir, cuando toque.</li>
                <li>Las cosas se van a complicar ahora, cuando añadáis
                    varios chóferes: puede haber errores de orden de
                    aparcamiento y de choques.  Debéis introducir mecanismos
                    de sincronización para que todo funcione.</li>
                <li>Acabad la práctica y probadla a velocidad normal y
                    a velocidad cero.</li>
                <li>Meted la opción de diferentes políticas de
                    gestión de la cola de tareas de los chóferes:
                    FIFO, prioridad de aparcamientos y prioridad de desaparcamientos.</li>
                <li>Añadid el resto de algoritmos</li>
                <li>Diseñad la forma de acabar sin problemas y llamad a
                    la función <code>PARKING_fin()</code>.</li>
                <li>Pulid los últimos detalles.</li>
            </ol>
            <br><br>
        <li><h3>Plazo de presentación.</h3>
            Consultad la página de entrada de la asignatura.
            <br><br>
        <li><h3>Normas de presentación.</h3>
            <a href="../normas.htm">Acá</a> están.
            Además de estas normas, en esta práctica se debe entregar
            un esquema donde aparezcan los semáforos usados, sus
            valores iniciales, los buzones, y mesajes pasados y un 
            seudocódigo sencillo para cada
            proceso con las operaciones <i>wait</i> y <i>signal</i>,
            <i>send</i> y <i>receive</i>
            realizadas sobre ellos. Por ejemplo, si se tratara de
            sincronizar dos procesos C y V para que produjeran
            alternativamente consonantes y vocales, comenzando por
            una consonante, deberíais entregar algo parecido a esto:
<pre>     SEMÁFOROS Y VALOR INICIAL: SC=1, SV=0.

     SEUDOCÓDIGO:

             C                                V
            ===                              ===
       Por_siempre_jamás               Por _siempre_jamás
          {                               {
           W(SC)                           W(SV)
           escribir_consonante             escribir_vocal
           S(SV)                           S(SC)
           }                               }
</pre>
            Daos cuenta de que lo que importa en el pseudocódigo es
            la sincronización.  El resto puede ir muy esquemático.
            Un buen esquema os facilitará muchísimo la defensa.
            <br><br></li>
        <li><h3>Evaluación de la práctica.</h3>
            Dada la dificultad para la corrección de programación
            en paralelo, el criterio que se seguirá para la evaluación
            de la práctica será: si
            <ol type="a">
                <li>la práctica cumple las especificaciones de este
                    enunciado y,
                <li>la práctica no falla en ninguna de las ejecuciones
                    a las que se somete y,
                <li>no se descubre en la práctica ningún fallo de
                    construcción que pudiera hacerla fallar, por
                    muy remota que sea esa posibilidad...
            </li></ol>
            se aplicará el principio de "presunción de inocencia"
            y la práctica estará aprobada. La nota, a partir de ahí,
            dependerá de la simplicidad de las técnicas de sincronización
            usadas, la corrección en el tratamiento de errores, 
            la cantidad y calidad del trabajo realizado, etc.
            <br><br>
        <li><h3>LPEs.</h3>
            <ol type="I">
                <li> ¿Se puede usar la biblioteca en un Linux de 64 bits?
                     <a href="../amd64.htm">Aquí</a> se os indican las claves.</li>
                <li> ¿Se puede proporcionar la biblioteca para el
                     Sistema Operativo X, procesador Y?  Por problemas
                     de eficiencia en la gestión y mantenimiento del 
                     código no se
                     proporcionará la biblioteca más que para
                     Solaris-SPARC y Linux de 32 bits.  A veces podéis
                     lograr encontrar una solución mediante el uso
                     de máquinas virtuales.</li>
                <li> ¿Dónde poner un semáforo? Dondequiera que 
                     uséis la
                     frase, "el proceso puede llegar a esperar hasta que..." 
                     es un buen candidato a que aparezca una operación
                     <i>wait</i> sobre un semáforo. Tenéis que plantearos
                     a continuación qué proceso hará <i>signal</i> 
                     sobre ese presunto semáforo, dónde lo hará y 
                     cuál será su valor inicial.</li>
                <li> Si ejecutáis la práctica en <i>segundo plano</i>
                     (con ampersand (&amp;)) es normal que al pulsar
                     CTRL+C el programa no reaccione. El terminal sólo
                     manda <code>SIGINT</code> a los procesos que estén
                     en primer plano. Para probarlo, mandad el proceso
                     a primer plano con <code>fg %</code> y pulsad
                     entonces CTRL+C.</li>
                <li> Un "truco" para que sea menos penoso el tratamiento
                     de errores consiste en dar valor inicial a los
                     identificadores de los recursos IPC igual a -1.
                     Por ejemplo, <code>int semAforo=-1</code>. En la
                     manejadora de <code>SIGINT</code>, sólo si
                     <code>semAforo</code> vale distinto de -1,
                     elimináis el recurso con <code>semctl</code>.
                     Esto es lógico: si vale -1 es porque no se ha
                     creado todavía o porque al intentar crearlo
                     la llamada al sistema devolvió error. En ambos casos,
                     no hay que eliminar el recurso.</li>
                <li> Para evitar que todos los identificadores de
                     recursos tengan que ser variables globales
                     para que los vea la manejadora de 
                     <code>SIGINT</code>, podéis declarar una
                     estructura que los contenga a todos y así
                     sólo gastáis un identificador del espacio
                     de nombres globales.</li>
                <li> A muchos os da el error "Interrupted System Call".
                     Mirad la sesión dedicada a las señales, apartado quinto.
                     Allí
                     se explica lo que pasa con <code>wait</code>.
                     A vosotros os pasa con <code>semop</code>, pero es
                     lo mismo. De las dos soluciones que propone el
                     apartado, debéis usar la segunda.</li>
                <li> A muchos, la práctica os funciona exasperantemente
                     lenta en encina. Debéis considerar que la máquina
                     cuando la probáis está cargada, por lo que debe
                     ir más lento que en casa o en el linux de clase.</li>
                <li> A aquellos que os dé "Bus error (Core dumped)" al
                     dar valor inicial al semáforo, considerad que hay
                     que usar la versión de <code>semctl</code> de
                     Solaris (con <code>union semun</code>), como
                     se explica en la sesión de semáforos.</li>
                <li> Al acabar la práctica, con CTRL+C, al ir a borrar
                     los recursos IPC, puede ser que os ponga
                     "<code>Invalid argument</code>", pero, sin embargo,
                     se borren bien. La razón de esto es que habéis
                     registrado la manejadora de <code>SIGINT</code> para
                     todos los procesos. Al pulsar CTRL+C, la señal la
                     reciben todos, el padre y los otros procesos. El primero 
                     que obtiene la CPU salta a su manejadora y borra los
                     recursos. Cuando saltan los demás, intentan borrarlos,
                     pero como ya están borrados, os da el error.</li>
                <li> El compilador de encina tiene un bug. El error típicamente
                     os va a ocurrir cuando defináis una variable entera en
                     memoria compartida. Os va a dar
                     <code>Bus Error. Core dumped</code> si no definís el
                     puntero a esa variable apuntando a una dirección que 
                     sea múltiplo de cuatro. El puntero que os devuelve
                     <code>shmat</code>, no obstante, siempre será una
                     dirección múltiplo de cuatro, por lo que solo os
                     tenéis que preocupar con que la dirección sea múltiplo de
                     cuatro respecto al origen de la memoria compartida.
                     La razón se escapa un poco al nivel de este curso y
                     tiene que ver con el alineamiento de direcciones de
                     memoria en las instrucciones de acceso de palabras en
                     el procesador RISC de encina.</li>
                <li> Todos vosotros, tarde o temprano, os encontráis con
                     un error que no tiene explicación: un proceso que
                     desaparece, un semáforo que parece no funcionar, etc.
                     La actitud en este caso no es tratar de justificar la
                     imposibilidad del error. Así no lo encontraréis.
                     Tenéis que ser muy sistemáticos. Hay un árbol entero
                     de posibilidades de error y no tenéis que descartar
                     ninguna de antemano, sino ir podando ese árbol. Tenéis
                     que encontrar a los procesos responsables y tratar de
                     localizar la línea donde se produce el error. Si el
                     error es "<code>Segmentation fault. Core dumped</code>",
                     la línea os la dará si aplicáis lo que aparece en la
                     sección <a href="debug.htm">Manejo del depurador</a>.
                     En cualquier otro caso, no os quedará más remedio que
                     depurar mediante órdenes de impresión dentro del
                     código.
                     <br><br>
                     Para ello, insertad líneas del tipo:<pre>                     fprintf(stderr,"%d:...",getpid(),...);</pre>
                     donde sospechéis que hay problemas. En esas líneas
                     identificad siempre al proceso que imprime el mensaje.
                     Comprobad todas las hipótesis, hasta las más evidentes.
                     Cuando ejecutéis la práctica, redirigid el canal de
                     errores a un fichero con <code>2&gt;salida</code>.
                     <br><br>
                     Si cada proceso pone un identificador de tipo "P1",
                     "P2", etc. en sus mensajes, podéis quedaros con las
                     líneas que contienen esos caracteres con:<pre>                     grep "P1" salida &gt; salida2</pre></li>
                <li> Si aparecen errores de acceso a memoria, especialmente
                     a partir de la versión 2 de la biblioteca
                     y en la fución <code>isValidHandle</code>, puede
                     ser porque creais los procesos auxiliares antes
                     de llamar a <code>PARKING_inicio</code>.  Todos los
                     procesos se deben crear después de llamar a
                     <code>PARKING_inicio</code>.</li>
            </ol>
    </li></ol>
<hr>
© 2017 Guillermo González Talaván.
<hr>


</body></html>
